import json
import os
from dataclasses import dataclass
from pathlib import Path
from typing import Callable

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from Bio import AlignIO, SeqIO

from local_conservation_scores.tools import pairwise_tools
from local_seqtools import general_utils as tools
from local_seqtools import pssms


class ConserGene:
    """
    This class is for reading the json files generated by the conservation pipeline.
    """

    def __init__(self, json_filepath, filepath_converter: Callable | None = None):
        if filepath_converter is not None:
            json_filepath = filepath_converter(json_filepath)
        self.json_filepath = Path(json_filepath)
        with open(self.json_filepath, "r") as f:
            self.info_dict = json.load(f)

        self.reference_index = self.info_dict["reference_index"]
        if "critical_error" in self.info_dict:
            self.critical_error = self.info_dict["critical_error"]
            return
        self.query_gene_id = self.info_dict["query_gene_id"]
        self.hit_sequence = self.info_dict["hit_sequence"]
        self.query_sequence = self.info_dict["query_sequence"]
        self.hit_start_position = self.info_dict["hit_start_position"]
        self.hit_end_position = self.info_dict["hit_end_position"]
        self.hit_in_idr = self.info_dict["hit_in_idr"]
        self.idr_start = self.info_dict["idr_start"]
        self.idr_end = self.info_dict["idr_end"]
        if "analysis_folder" in self.info_dict:
            self.analysis_folder = self.info_dict["analysis_folder"]
        self.levels_passing_filters = self.info_dict["levels_passing_filters"]
        self.level_objects: dict[str, ConserLevel] | None = None
        self.aln_score_objects: dict[str, LevelAlnScore] | None = None

        self.hit_st_in_idr = self.hit_start_position - self.idr_start
        self.hit_end_in_idr = self.hit_end_position - self.idr_start
        self.query_idr_sequence = self.query_sequence[self.idr_start : self.idr_end + 1]

    def get_level_obj(self, level, filepath_converter: None | Callable = None):
        return ConserLevel(
            self.info_dict["orthogroups"][level],
            query_gene_id=self.query_gene_id,
            filepath_converter=filepath_converter,
        )

    def load_levels(self, filepath_converter: None | Callable = None):
        self.level_objects = {}
        for level in self.levels_passing_filters:
            self.level_objects[level] = self.get_level_obj(
                level, filepath_converter=filepath_converter
            )

    def get_aln_score_obj(
        self,
        level,
        score_key,
        bg_region=None,
        num_bg_scores_cutoff=20,
        filepath_converter: None | Callable = None,
    ):
        level_obj = self.get_level_obj(level, filepath_converter=filepath_converter)
        return LevelAlnScore.from_conser_level(
            level_obj,
            score_key,
            bg_region=bg_region,
            num_bg_scores_cutoff=num_bg_scores_cutoff,
            query_gene_id=self.query_gene_id,
            filepath_converter=filepath_converter,
        )

    def load_aln_scores(
        self,
        score_key,
        bg_region=None,
        num_bg_scores_cutoff=20,
        filepath_converter: None | Callable = None,
    ):
        self.aln_score_objects = {}
        self.load_levels(filepath_converter=filepath_converter)
        for level, level_obj in self.level_objects.items():
            self.aln_score_objects[level] = self.get_aln_score_obj(
                level,
                score_key,
                bg_region=bg_region,
                num_bg_scores_cutoff=num_bg_scores_cutoff,
                filepath_converter=filepath_converter,
            )

    def _overwrite_json(self):
        with open(self.json_filepath, "w") as f:
            json.dump(self.info_dict, f, indent=4)

    def add_item_to_json(self, key, value, save_json=True):
        self.info_dict[key] = value
        if save_json:
            self._overwrite_json()

    def add_item_to_lvl_orthogroup(self, key, value, level, save_json=True):
        self.info_dict["orthogroups"][level][key] = value
        if save_json:
            self._overwrite_json()


class ConserLevel:
    def __init__(
        self,
        lvl_dict,
        query_gene_id=None,
        filepath_converter: None | Callable = None,
    ):
        self.info_dict = lvl_dict
        if filepath_converter is not None:
            self.alignment_file = filepath_converter(lvl_dict["alignment_file"])
        else:
            self.alignment_file = lvl_dict["alignment_file"]
        self.hit_aln_start = lvl_dict["hit_aln_start"]
        self.hit_aln_end = lvl_dict["hit_aln_end"]
        self.idr_aln_start = lvl_dict["idr_aln_start"]
        self.idr_aln_end = lvl_dict["idr_aln_end"]
        self.query_aln_sequence = lvl_dict["query_aln_sequence"]
        self.hit_aln_sequence = lvl_dict["hit_aln_sequence"]
        self.num_clustered_ldos = lvl_dict["num_clustered_ldos"]
        self.conservation_scores = lvl_dict["conservation_scores"]
        with open(self.alignment_file, "r") as f:
            self.aln = AlignIO.read(f, "fasta")
        if query_gene_id is not None:
            self.query_gene_id = query_gene_id
            self.aln = self.reorder_aln(query_gene_id)

    def get_idr_dict(self):
        idr_aln = self.aln[:, self.idr_aln_start : self.idr_aln_end + 1]
        idrs = tools.strip_dashes_from_sequences(list(idr_aln))  # type: ignore
        idrs = {i.id: str(i.seq) for i in idrs}
        return idrs

    def reorder_aln(self, query_gene_id):
        """order the alignment so that the sequence with the query gene id is first"""
        aln_dict = {i.id: i for i in self.aln}
        query_seq = aln_dict.pop(query_gene_id)
        aln_list = [query_seq] + list(aln_dict.values())
        return AlignIO.MultipleSeqAlignment(aln_list)


class LevelAlnScore(ConserLevel):

    def __init__(
        self,
        lvl_dict,
        score_key,
        bg_region=None,
        num_bg_scores_cutoff=20,
        query_gene_id=None,
        filepath_converter: None | Callable = None,
    ):
        super().__init__(
            lvl_dict, query_gene_id=query_gene_id, filepath_converter=filepath_converter
        )
        # self.scores = None
        # self.score_mask = None
        # self.gap_mask = None
        self.z_scores: list | None = None
        self.bg_scores: list | None = None
        self.z_score_failure: str | None = None
        self.hit_aln_scores: list | None = None
        self.hit_scores: list | None = None
        self.hit_aln_z_scores: list | None = None
        self.hit_z_scores: list | None = None
        if filepath_converter is not None:
            self.score_file = filepath_converter(
                self.conservation_scores[score_key]["file"]
            )
        else:
            self.score_file = self.conservation_scores[score_key]["file"]
        self.score_function_name = self.conservation_scores[score_key][
            "score_function_name"
        ]
        self.score_params = self.conservation_scores[score_key]["score_params"]
        self.calculate_z_scores_bg_region(score_key, bg_region, num_bg_scores_cutoff)
        self.calculate_hit_scores()
        if self.z_score_failure is None:
            self.calculate_hit_zscores()

    @classmethod
    def from_conser_level(
        cls,
        conser_level: ConserLevel,
        score_key,
        bg_region=None,
        num_bg_scores_cutoff=20,
        query_gene_id=None,
        filepath_converter: None | Callable = None,
    ):
        return cls(
            conser_level.info_dict,
            score_key,
            bg_region,
            num_bg_scores_cutoff,
            query_gene_id=query_gene_id,
            filepath_converter=filepath_converter,
        )

    def load_scores(self, score_key):
        with open(self.score_file, "r") as f:
            score_dict = json.load(f)
        self.scores = score_dict["scores"]
        self.score_mask = score_dict["score_mask"]
        self.gap_mask = score_dict["gap_mask"]

    def calculate_z_scores_bg_region(
        self, score_key, bg_region=None, num_bg_scores_cutoff=20
    ):
        self.load_scores(score_key)
        if bg_region is None:
            bg_region = [self.idr_aln_start, self.idr_aln_end + 1]
        try:
            z_score_dict = tools.calculate_z_score_bg_region(
                self.scores,
                self.score_mask,
                bg_region,
                num_bg_scores_cutoff=num_bg_scores_cutoff,
            )
        except ValueError as ve:
            self.z_score_failure = str(ve)
            return
        self.z_scores = z_score_dict["z_scores"]
        self.bg_scores = z_score_dict["bg_scores"]

    def calculate_hit_scores(self):
        hit_slice = slice(self.hit_aln_start, self.hit_aln_end + 1)
        self.hit_aln_scores = self.scores[hit_slice]
        nongap_inds = tools.get_non_gap_indexes(self.hit_aln_sequence)
        self.hit_scores = list(np.array(self.hit_aln_scores)[nongap_inds])

    def calculate_hit_zscores(self):
        hit_slice = slice(self.hit_aln_start, self.hit_aln_end + 1)
        self.hit_aln_z_scores = self.z_scores[hit_slice]
        nongap_inds = tools.get_non_gap_indexes(self.hit_aln_sequence)
        self.hit_z_scores = list(np.array(self.hit_aln_z_scores)[nongap_inds])


# ==============================================================================
# // pairwise tools - in development
# ==============================================================================


def plot_score_bar_plot(ax, score_list, query_seq, mask=None, **kwargs):
    if mask is not None:
        score_list = np.array(score_list)
        score_list[[not i for i in mask]] = 0
        score_list = list(score_list)
    ax.bar(
        list(range(len(score_list))),
        score_list,
    )
    ax = _format_bar_plot(ax, query_seq, bar_ylim=False, **kwargs)
    return ax


def _format_bar_plot(ax, xlabel_sequence: str, bar_ylim=[0, 1], labelsize=16, **kwargs):
    """format bar plot"""
    _ = ax.set_xticks(
        list(range(len(xlabel_sequence))),
        labels=list(xlabel_sequence),
    )
    ax.set_xlim(-0.5, len(xlabel_sequence) - 0.5)
    ax.tick_params(axis="x", which="major", labelsize=labelsize)
    if bar_ylim:
        ax.set_ylim(bar_ylim)
    return ax


def plot_logo(ax, str_list, tick_label_str, labelsize=16):
    counts = pssms.alignment_2_counts(str_list, show_plot=False, heatmap=False)
    lm.Logo(counts, color_scheme="chemistry", ax=ax)
    ax.set_ylim(0, len(str_list))
    _ = ax.set_xticks(
        list(range(len(str_list[0]))),
        labels=list(tick_label_str),
    )
    ax.tick_params(axis="x", which="major", labelsize=labelsize)
    return ax


@dataclass
class PairwiseScoreResults:
    flanked_hit: str
    flanked_hit_start_position_in_idr: int
    original_hit_st_in_flanked_hit: int
    original_hit_end_in_flanked_hit: int
    score_function_name: str
    score_params: dict
    lflank: int
    rflank: int
    matrix_file: str | Path
    flanked_hit_sequence: str
    flanked_hit_scores: list
    flanked_hit_z_scores: list
    hit_sequence: str
    hit_scores: list
    hit_z_scores: list
    mat2score_params: dict


class LevelPairwiseScore:

    def __init__(self, level_obj: ConserLevel, score_key):
        self.level_obj = level_obj
        self.score_key = score_key
        self.score_dict = level_obj.conservation_scores[score_key]
        self.matrix_file = self.score_dict["matrix_file"]
        self.flanked_hit = self.score_dict["flanked_hit"]
        self.k = len(self.flanked_hit)
        self.flanked_hit_start_position_in_idr = self.score_dict[
            "flanked_hit_start_position_in_idr"
        ]
        self.original_hit_st_in_flanked_hit = self.score_dict[
            "original_hit_st_in_flanked_hit"
        ]
        self.original_hit_end_in_flanked_hit = self.score_dict[
            "original_hit_end_in_flanked_hit"
        ]
        # self.results = PairwiseScoreResults(**self.score_dict)
        self.matrices = pairwise_tools.import_pairwise_matrices(self.matrix_file)
        self.subseqdf = self.matrices["subseq_dataframe"].fillna("-" * self.k)
        self.scoredf = self.matrices["score_dataframe"]
        self.positiondf = self.matrices["position_dataframe"]
        if "reciprocal_best_match_dataframe" in self.matrices:
            self.rbmdf = self.matrices["reciprocal_best_match_dataframe"]
            self.rbmdf = self.rbmdf.fillna(False)

    def get_seqlist(self, query_position=None, reciprocal_best_match=False):
        if query_position is None:
            query_position = self.flanked_hit_start_position_in_idr
        query_seq = self.subseqdf.loc[query_position, "reference_kmer"]
        if reciprocal_best_match:
            hitdf = pd.concat(
                [
                    self.subseqdf.loc[query_position],
                    self.rbmdf.loc[query_position],
                ],
                axis=1,
                keys=["subseq", "rbm"],
            )
            hitdf.loc["reference_kmer", "rbm"] = True
            seqlist = hitdf[hitdf["rbm"]]["subseq"].to_list()
        else:
            seqlist = self.subseqdf.loc[
                self.flanked_hit_start_position_in_idr
            ].to_list()
        return seqlist, query_seq

    def plot_logo(self, ax, seq_list, query_seq=None):
        if query_seq is None:
            query_seq = self.flanked_hit
        plot_logo(ax=ax, str_list=seq_list, tick_label_str=query_seq)
        return ax

    def plot_score_bar_plot(self, ax, score_list, query_seq=None):
        if query_seq is None:
            query_seq = self.flanked_hit
        plot_score_bar_plot(ax=ax, score_list=score_list, query_seq=query_seq)
        return ax

    def plot_scoreslogo_plot(
        self, score_list, axes=None, query_position=None, reciprocal_best_match=False
    ):
        if axes is None:
            fig, axes = plt.subplots(nrows=2, ncols=1, figsize=(10, 4))
        seqlist, query_seq = self.get_seqlist(query_position, reciprocal_best_match)
        self.plot_score_bar_plot(ax=axes[0], score_list=score_list, query_seq=query_seq)
        self.plot_logo(ax=axes[1], seq_list=seqlist, query_seq=query_seq)
        counts = pssms.alignment_2_counts(seqlist, show_plot=False, heatmap=False)
        return axes, counts


def flank_hit_lr(
    og: ConserGene,
    lflank: int,
    rflank: int,
):
    flanked_hit_st_idr, flanked_hit_end_idr, flanked_hit = tools.pad_hit(
        og.query_idr_sequence, og.hit_st_in_idr, og.hit_end_in_idr, lflank, rflank
    )
    orig_hit_st_in_flanked_hit = og.hit_st_in_idr - flanked_hit_st_idr
    orig_hit_end_in_flanked_hit = og.hit_end_in_idr - flanked_hit_st_idr


def flank_hit_target_k(
    og: ConserGene,
    k: int,
):
    flanked_hit_st_idr, flanked_hit_end_idr, flanked_hit = pad_hit_target_length_exact(
        og.query_idr_sequence, og.hit_st_in_idr, og.hit_end_in_idr, target_hit_length=k
    )
    orig_hit_st_in_flanked_hit = og.hit_st_in_idr - flanked_hit_st_idr
    orig_hit_end_in_flanked_hit = og.hit_end_in_idr - flanked_hit_st_idr
    assert (
        len(flanked_hit) == k
    ), f"length of flanked hit and k are not equal: len({flanked_hit})!={k}"
